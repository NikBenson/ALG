\section{Implementierung}
	Es gibt viele verschiedene Variationen, Samplesort zu implementieren. Zu viele, um sie hier alle zu nennen.
	Im Folgenden sind die bekanntesten Variationen dargestellt.\\
	Dazu sind zunächst ein paar Grundbegriffe von Nöten:
	\paragraph{Splitter}
		Splitter wurden bereits in der Einleitung erwähnt.
		Dort haben wir uns damit begnügt, diese mit den Pivot Elementen beim Quicksort zu vergleichen.
		Die Konzepte sind dabei sehr ähnlich.\\
		Während Quicksort die Daten mit dem Pivot Element in 2 Sektionen unterteilt, da binär die einfachste Aufteilungsmöglichkeit ist, wenn die Anzahl irrelevant ist, unterteilt Samplesort die Daten mit $n$ Splittern in $n+1$ Buckets.
	\paragraph{Bucket}
		Ein Bucket ist der Bereich zwischen zwei benachbarten Splittern, so wie die beiden Bereiche neben dem größten sowie kleinsten Splitter.\\
		Wenn $\{10, 20, 30\}$ die 3 Splitter sind, dann ergeben sich daraus also die Buckets $\{(-\infty;10],\allowbreak [10;20],\allowbreak [20;30],\allowbreak [30;\infty)\}$.\\
		Wichtig ist dabei, dass Elemente, die den selben Wert, wie ein Splitter haben, entweder in den Bucket links, oder rechts, von jenem, eingeordnet werden können.\\
		Das Ziel ist dabei häufig, die Anzahl der Buckets identisch zur Anzahl der verfügbaren Prozessorkerne zu setzen, damit die Buckets parallel sortiert werden. Dies ist in \ref{sec:multithreading} weiter ausgeführt.

	\subsection{Grundger\"ust}
		Der grundlegende Aufbau ist dabei immer identisch und in \ref{fig:skeletton} beispielhaft dargestellt:
		\lstinputlisting[language=C, caption=Samplesort Implementierung, label=fig:skeletton]{../code/src/samplesort/samplesort.c}
		Zu erkennen sind 3 schritte, denen im folgenden auch jeweils eine Überschrift gewidmet ist:
		\begin{enumerate}
			\item Auswählen von $\textit{bucketsCount}-1$ splittern
			\item Zuordnen der Werte zu den sich daraus ergebenden Buckets
			\item Sortieren der Buckets
		\end{enumerate}
		Der Datentyp \textit{Array}, der zu sortierenden Daten \textit{data}, ist gegeben als ein Addressbereich im RAM mit einem \textit{start} und einem \textit{end} Pointer.

	\subsection{Auswahl der Splitter}
		Das Ziel bei der Auswahl der Splitter ist, dass möglichst gleich große Buckets entstehen.
		\lstinputlisting[language=C, caption=Auswahl der Splitter, label=fig:select_splitters]{../code/src/samplesort/select_splitters.c}
		Während der grundlegende Aufbau, wie in \ref{fig:select_splitters} dargestellt, immer der selbe ist, kann die Auswahl der Sample auf 4 verschiedene Arten erfolgen:
		\begin{itemize}
			\item \ref{sec:even} Gleichmäßig
			\item \ref{sec:semi-random} Semi-Zufällig
			\item \ref{sec:random} Zufällig
			\item \ref{sec:block} Block
		\end{itemize}
		
		\paragraph{Oversampeling}
			Die Sample ist dabei ein ausgewählter Teilbereich der Daten. Der \textit{oversamplingFactor} gibt dabei an, wie wie groß die Sample ist.\\
			Die Sample wird sortiert und die Splitter werden gleichmäßig aus der Sample entnommen.
			Dieser Prozess dient dazu, dass die Splitter die Buckets möglichst gleichmäßig unterteilen.
			
		\subsubsection{Gleichmäßig}
			\label{sec:even}
			pick evenly spaced samples using a step of l/s, where l is the number of elements on the thread

		\subsubsection{Semi-Zufällig}
			\label{sec:semi-random}
			pick approximately evenly spaced samples using a step of a random number between 1 and l/s

		\subsubsection{Zufällig}
			\label{sec:random}
			pick the samples randomly from the data on the thread

		\subsubsection{Block}
			\label{sec:block}
			pick the sequential first s data elements on the thread
			\lstinputlisting[language=C, caption=Auswahl der Sample mit dem Block Verfahren, label=fig:select_sample_bloc]{../code/src/samplesort/choose_sample/block.c}

	\subsection{Zuordnen jeden Wertes zu dem passenden Bucket}
		\lstinputlisting[language=C, caption=Finden des richtigen Buckets]{../code/src/samplesort/place_elements_in_appropriate_bucket.c}

	\subsection{Sortieren der Buckets}
		Um den Sortierprozess fertig zu stellen ist es noch notwendig, alle Buckets zu sortieren.
		Zu diesem Zweck gibt es 2 Überkategorien:
		\subsubsection{Original}
			Im Original \autocite{frazer-1970} wird Quicksort verwendet, um die Buckets zu sortieren.
			Der zugrundeliegende Gedanke ist, dass, durch das initiale gleichmäßige verteilen der Elemente, jeder Prozessorkern nun annähernd gleich viele Elemente bearbeiten soll.\\
			Auch wenn im Original Quicksort verwendet wird, so wird dieser Gedanke auch von jeglichem Divide-and-Conquer Algorithmus mit einer durchschnittlichen Laufzeit von annähernd $O(n\log{n})$\footnote{Diese Angabe ist ein Richtwert. Vorausgesetzt es gibt sinnvolle Gründe, wie das verringern von Vergleichen, kann es sinnvoll sein, diese Laufzeitkomplexität auch im größeren Maße zu überschreiten.} umgesetzt. 
		\subsubsection{Rekursiv}
			Dem entgegen steht die rekursive Implementierung.
			Diese ist auch in \ref{fig:skeletton} umgesetzt.\\
			Hier ist der Vorteil der geringen Anzahl an Vergleichen von Samplesort länger gegeben. Als Rekursionsanker dient in der Regel ein Threshold.
			Überschreitet die durchschnittliche Größe eines Buckets diese Zahl, so wird zu einem alternativen Sortieralgorithmus gewechselt. \\
			Hier bietet sich Insertion an, da dieser für kleine Datenmengen optimal ist. \autocite{geeksforgeeks-2021} 
			In vielen Ausführungen ist hier allerdings auch ein Quicksort zu finden.
			Die Entscheidung sollte von der Größe des Thresholds getrieben sein.
			
